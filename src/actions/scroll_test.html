<!DOCTYPE html>

<html>
<head>
	<title>Ben help</title>
	<script>
		// if debounce is enabled, they must pause for debounce ms first
		// "cancel" is attached to the function, which resets timers
		function throttle(fn, ms, debounce = false){
			var last_run = 0;
			const throttled_fn = function(){
				var cur = performance.now();
				if (cur-last_run >= ms){
					last_run = cur;
					fn.apply(this, arguments);
				}
				else if (debounce)
					last_run = cur;
			}
			throttled_fn.cancel = () => { last_run = 0; };
			return throttled_fn;
		}
		
		function register_scroll_handlers(scroll_page){
			// Scroll wheel input
			window.addEventListener("wheel", throttle((e) => {
				scroll_page(Math.sign(e.deltaY));
			}, 800, false));
			
			// Keyboard input
			const key_scroll = throttle((e) => {
				if (e.key == "ArrowDown" || e.key == "PageDown")
					scroll_page(1);
				else if (e.key == "ArrowUp" || e.key == "PageUp")
					scroll_page(-1);
			}, 500, false);
			window.addEventListener("keypress", key_scroll);
			// don't want to throttle individual key presses... just if they hold down the key
			window.addEventListener("keyup", key_scroll.cancel);
			
			// Mouse/pointer/touch drag input
			// TODO: use different thresholds when dragging an html custom scrollbar
			var origin, dragging = null;
			const move_fn = (e) => {
				let diff = origin-e.clientY;
				if (Math.abs(diff) > 100){
					origin = e.clientY;
					scroll_page(Math.sign(diff));
				}
				// TODO: if we don't scroll page, can do a preview of the drag, e.g. with marginTop = diff+"px"
			};
			const etypes = [
				["touchstart","touchend","touchmove"],
				["pointerdown","pointerup","pointermove"],
				["mousedown","mouseup","mousemove"]
			];
			for (const [edown, eup, emove] of etypes){
				window.addEventListener(edown, (e) => {
					origin = e.clientY;
					// browser may support multiple event types; cancel so we only on first
					if (!dragging){
						dragging = eup;
						window.addEventListener(emove, move_fn);
						e.preventDefault();
					}
				});
				window.addEventListener(eup, (e) => {
					window.removeEventListener(emove, move_fn);
					if (e.type == dragging)
						dragging = null;
				});
			}
		}
		
		document.addEventListener("DOMContentLoaded", () => {
			var page = 0;
			register_scroll_handlers((direction) => {
				// TODO: clamp here if needed
				page += direction;
				// display
				let s = document.createElement("span");
				s.textContent = page+",";
				document.body.appendChild(s);
			});
		});
	</script>
</head>
<body>

</body>
</html>
